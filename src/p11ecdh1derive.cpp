// -*- mode: c++; c-file-style:"stroustrup"; -*-

// p11perftest: a simple benchmarker for PKCS#11 interfaces
//
// Author: Eric Devolder <eric.devolder@mastercard.com>
//
// (c)2018 MasterCard

#include <iostream>
#include <botan/asn1_obj.h>
#include <botan/ec_group.h>
#include "p11ecdh1derive.hpp"

namespace P11ECDH1 {

    // a public key (point) on secp256r1
    static const std::vector<Byte> m_secp256r1_pubkey {
	// uncompressed
	0x04,
	// x coordinate
	0x34, 0xe3, 0xe7, 0x64, 0x53, 0xc8, 0x5c, 0x3d, 0x47, 0x9a, 0xca, 0x9a, 0xc9, 0x01, 0x26, 0x07,
	0x95, 0x27, 0x5e, 0x0e, 0x2b, 0x4b, 0x7b, 0xe3, 0x6d, 0x2c, 0xaf, 0xe5, 0x54, 0x62, 0x56, 0x3c,
	// y coordinate
	0xac, 0xa4, 0xc2, 0xbb, 0xf4, 0xfa, 0x31, 0x77, 0x9a, 0x1d, 0x66, 0x89, 0xe6, 0x63, 0xbd, 0x77,
	0x1b, 0x0f, 0xcf, 0x2b, 0x46, 0x73, 0xea, 0x09, 0x06, 0x81, 0xe2, 0x44, 0x53, 0xe9, 0xa8, 0x8e
    };

    // a public key (point) on secp384r1
    static const std::vector<Byte> m_secp384r1_pubkey {
	// uncompressed
	0x04,
	// x coordinate
	0xba, 0xae, 0x9c, 0xec, 0x21, 0x48, 0x72, 0xa4, 0xc8, 0x0d, 0x4b, 0x8a, 0xae, 0x9d, 0x56, 0x3e,
	0xaa, 0x10, 0x33, 0xce, 0xcd, 0x5b, 0xaf, 0x94, 0xb4, 0x10, 0x9c, 0xec, 0x2e, 0xc5, 0x51, 0x45,
	0xa1, 0x02, 0x4b, 0x0a, 0x77, 0xfa, 0xe1, 0x76, 0x69, 0x56, 0xfc, 0xfe, 0x9f, 0x12, 0x35, 0x4f,
	// y coordinate
	0xed, 0x72, 0xa6, 0x40, 0x93, 0xe6, 0xb6, 0x2a, 0xb9, 0x6d, 0x82, 0x30, 0xa2, 0x9c, 0xbd, 0xc1,
	0x27, 0x74, 0x36, 0x90, 0x40, 0x6c, 0x01, 0x20, 0xbd, 0xf1, 0x07, 0x3d, 0x2a, 0x2b, 0x37, 0xc0,
	0x99, 0x15, 0xa8, 0xcc, 0xb1, 0x52, 0x76, 0xf5, 0x34, 0x59, 0xe6, 0xeb, 0xc2, 0xf2, 0x0b, 0xa5
    };

    // a public key (point) on secp521r1
    static const std::vector<Byte> m_secp521r1_pubkey {
	// uncompressed
	0x04,
	// x coordinate
	0x00, 0x3c, 0x9d, 0xec, 0xb7, 0x86, 0xa2, 0xe7, 0xca, 0xcb, 0xcd, 0x72, 0x84, 0xf2, 0x11, 0x66,
	0x04, 0xca, 0x62, 0x33, 0x9c, 0x36, 0x0d, 0x9d, 0xe1, 0xa1, 0x6b, 0xff, 0xf6, 0x7d, 0x86, 0x3b,
	0x05, 0x36, 0xce, 0x65, 0x3f, 0xf3, 0x93, 0x4f, 0x5f, 0xed, 0x5b, 0xf9, 0x72, 0x27, 0x81, 0x6a,
	0x6e, 0xb8, 0xad, 0xbc, 0xd8, 0xba, 0xcd, 0x97, 0x4d, 0xcc, 0x73, 0xfd, 0x8d, 0x84, 0x63, 0x3d,
	0xe1, 0xbc,
	// y coordinate
	0x00, 0xab, 0x07, 0xc2, 0x9c, 0x04, 0x77, 0xad, 0xc4, 0xb9, 0xe8, 0x6d, 0x15, 0x7f, 0x44, 0x4b,
	0xd8, 0x6c, 0x68, 0x7a, 0x10, 0xc2, 0x9b, 0xc6, 0xda, 0x80, 0xcc, 0x5a, 0x3e, 0x3d, 0x69, 0xfa,
	0x8f, 0xaa, 0x33, 0x03, 0x7c, 0x86, 0x89, 0xa4, 0x7c, 0x6a, 0x88, 0x7a, 0x79, 0x26, 0x52, 0x9b,
	0x7d, 0xb9, 0x8c, 0x82, 0xab, 0x66, 0x42, 0x88, 0x78, 0x88, 0x04, 0x96, 0x8a, 0xfc, 0x74, 0xdb,
	0xbb, 0x2b
    };


    static const std::map< std::string, const std::vector<Byte> & > other_public {
	{ "secp256r1", m_secp256r1_pubkey },
	{ "secp384r1", m_secp384r1_pubkey },
	{ "secp521r1", m_secp521r1_pubkey },
    };
}


P11ECDH1DeriveBenchmark::P11ECDH1DeriveBenchmark(const std::string &label) :
    P11Benchmark( "ECDH1 Derive (CKM_ECDH1_DERIVE)", label, ObjectClass::PrivateKey ) { }


P11ECDH1DeriveBenchmark::P11ECDH1DeriveBenchmark(const P11ECDH1DeriveBenchmark & other) :
    P11Benchmark(other) {

    // the m_attributes is not copied
    // it will be initialized during call to prepare()
    m_template = nullptr;
}


inline P11ECDH1DeriveBenchmark *P11ECDH1DeriveBenchmark::clone() const {
    return new P11ECDH1DeriveBenchmark{*this};
}

void P11ECDH1DeriveBenchmark::prepare(Session &session, Object &obj, std::optional<size_t> threadindex)
{

    m_objhandle = obj.handle();
    m_derivedkey = 0;

    // detect what is the key type. Based on that, pick relevant public key.

    auto ec_params = obj.get_attribute_value(AttributeType::EcParams);
    Botan::EC_Group ec_group { ec_params };
    std::string curve_name = ec_group.get_curve_oid().to_formatted_string();

    m_ecdh1_derive_params.pPublicData = const_cast<Byte *>(P11ECDH1::other_public.at(curve_name).data());
    m_ecdh1_derive_params.ulPublicDataLen = P11ECDH1::other_public.at(curve_name).size();

    m_template = std::unique_ptr<SecretKeyProperties>(new SecretKeyProperties(KeyType::GenericSecret));
    m_template->set_sensitive(true);
    m_template->set_extractable(false);
    m_template->add_numeric(AttributeType::ValueLen, static_cast< Ulong >(m_payload.size()));

}

void P11ECDH1DeriveBenchmark::crashtestdummy(Session &session)
{
    session.module()->C_DeriveKey(session.handle(),
				  &m_mech_ecdh1_derive,
				  m_objhandle,
				  m_template->data(),
				  static_cast< Ulong >(m_template->count()),
				  &m_derivedkey);
}

void P11ECDH1DeriveBenchmark::cleanup(Session &session)
{
    if(m_derivedkey) {
	session.module()->C_DestroyObject(session.handle(), m_derivedkey); // cleanup freshly created key
	m_derivedkey = 0;
    }
}

